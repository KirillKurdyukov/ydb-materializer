# YDB Materializer Development Guide

Задача: обеспечить эффективное выполнение ad-hoc (генерируемых) запросов с простыми фильтрами (равенство, диапазон значений, префикс) и сортировкой, с выдачей первых 100 записей. Запросы формирует интерактивное приложение, критерии фильтрации задаёт пользователь в интерфейсе.

Структура данных нормализованная, атрибуты для фильтрации "разбросаны" по разным таблицам. Некоторые из таблиц "большие" (миллионы и миллиарды строк), некоторые - заведомо "маленькие" и редко меняющиеся (до тысяч строк, справочники).

Для связей между таблицами используются первичные ключи, либо определены необходимые индексы для переходов в обоих направлениях. Некоторые из связей требуют "детализации" (дополнительных полей "вид связи" или "идентификатор группы объектов"), что приводит к сложной системе соединений при попытке выразить структуру данных SQL-запросами на выборку.

Предлагаемый подход: материализовать все необходимые атрибуты в одной таблице. Материализацию обновлять в асинхронном режиме с использованием потоков данных Change Data Capture.

## Архитектурные заметки

Основные компоненты:
1. Модель данных для описания материализованного представления
2. Парсер конфигурационного формата
3. Валидатор конфигурации (+ загрузчик метаданных)
4. Компонент сбора изменений
5. Компонент применения изменений
6. Генератор SQL-запросов
7. Сбор изменений справочников
8. Агрегатор изменений справочников
9. Распределенный планировщик для управления заданиями

Целостность данных обеспечивается на построчном уровне (разные строки могут соответствовать разным моментам времени изменения основных таблиц, но внутри одной строки данные полностью согласованы). Гарантируется "итоговая" согласованность: при остановке изменений основных таблиц MV приходит в полностью согласованное состояние после завершения обработки всех записей об изменениях в changefeed.

Чтение и запись данных выполняется последовательно в разных транзакциях для исключения ошибок TLI в других пишущих транзакциях, которые меняют записи в исходных таблицах MV. Чтобы не допустить пропуски изменений, важно реализовать строго последовательную обработку записей об изменениях по каждому ключу. Это обеспечивается разделением обработки по диапазонам значений первичного ключа на основе структуры партиций основной таблицы-источника. Для каждого диапазона обработка ведётся строго последовательно: сперва чтение исходных данных запросом, потом запись результата, потом опять переход к чтению.

### Модель данных

Более-менее готова. Модификации при выявлении недоделок и новых потребностей.

- MvContext - полный загруженный набор метаданных
- MvTarget - SQL-трансформация в виде соединения нескольких таблиц, вертикальной проекции и опционально дополнительного фильтра
- MvJoinSource - одна из таблиц в составе SQL-трансформации
- MvJoinCondition - одно из условий (через AND) соединения таблиц, указывается в составе MvJoinSource для правой части
- MvComputation - метод вычисления поля или условия
- MvLiteral - целочисленная или строковая константа
- MvColumn - описание выходной колонки SQL-трансформации и метода её получения
- MvHandler - задание, включает несколько таблиц-источников и несколько материализованных представлений
- MvTableInfo - метаданные таблицы
- MvKeyInfo - метаданные первичного ключа, вместе со ссылкой на метаданные таблицы
- MvKeyPrefix - префикс первичного ключа таблицы
- MvKey - полный первичный ключ таблицы
- MvIssue - ошибка или предупреждение при обработке модельной информации

### Парсер конфигурационного формата

Готов, изменения при выявлении необходимых модификаций модели данных. Основан на грамматике ANLRv4.

### Валидатор конфигурации

Реализована загрузка конфигурации (псевдо-SQL-операторов) из файла и из таблицы и подача в парсер, с последующим вызовом валидатора. Валидатор включает несколько последовательно запускаемых фаз, при выявлении на очередной фазе критических ошибок дальнейшая обработка не производится.

Реализована загрузка описаний таблиц БД и привязка этих описаний к соответствующим сущностям.

Частично реализована валидация, недоделки:
- проверка состава колонок и типов данных MV
- нет автомата проверки синтаксической корректности генерируемых запросов
- корректных методов доступа при соединении таблиц в различных ситуациях

### Компонент сбора изменений

Вариант для CDC:
- Чтение изменений из CDC-топиков
- Фиксация позиции в CDC-стриме в ответ на обратный вызов из обработчика

Вариант для полного сканирования:
- Чтение ключей "самой левой таблицы" MV с настраиваемым ограничением интенсивности чтения
- Опционально - фильтр (используется при обработке изменений справочников)
- Подача полученных ключей в компонент применения изменений
- Фиксация позиции сканирования в виде записи в специальной табличке

### Компонент применения изменений

В конкретном экземпляре активна обработка изменений для определённого набора MV. Доступны операции включения и выключения обработки конкретного MV.

Используется N потоков обработки, в каждом из которых используется собственная входная очередь. В очередь поступают значения первичного ключа "самой левой" таблицы для сборки MV. Выбор конкретного обработчика (и очереди) осуществляется исходя из значения первичного ключа перед постановкой очереди.

У очереди есть два варианта подачи данных: нормальный (с ограничением на максимальный объём) и форсированный (без ограничения). Нормальный режим используют основные (штатные) источники изменений - CDC-топики, сканеры ключей. В нормальном режиме при заполнении очереди подача данных прекращается до появления в ней свободного пространства. Форсированный режим используется для внутренних трансформаций (дозагрузка ключей, преобразование записей в памяти) для исключения взаимо-блокировок обрабатывающих потоков. В форсированном режиме в очередь можно добавить данные фактически до исчерпания оперативной памяти.

Отдельным потоком периодически выполняется Describe для "самой левой" таблицы MV, и обновляются диапазоны значений ключей, привязанные к конкретным потокам обработки.

Каждый обработчик действует в цикле:
1. Получил записи об изменения из очереди (не более K штук)
2. Сгруппировал записи по таблицам, к которым они относятся
3. Сгруппировал далее по объектам подтверждения
4. Определил состав обработчиков, которым нужно подать записи
5. Подал записи в обработчики
6. Подтвердил обработку, вызвав объекты подтверждения

Типы обработчиков:
- ActionSync - собственно обновление записей
- ActionKeysTransform - трансформация записей без доступа к БД
- ActionKeysGrab - чтение ключей из БД дополнительным запросом

Основной обработчик - ActionSync:
1. Выполнил оператор чтения данных по ключам (отдельная читающая транзакция)
2. (если уже запущена запись) Дождался завершения предыдущей транзакции записи
3. Запустил запись данных, полученных на шаге 2

Запись выполняем через `UPSERT INTO mv SELECT * FROM AS_TABLE($input)`. В перспективе - поддержать BulkUpsert, активировать его автоматически, если на MV нет индексов.

### Генератор SQL-запросов

Умеет строить необходимые SQL-запросы на основе заданной SQL-трансформации. Один из приёмов - построение новой SQL-трансформации из уже существующей, путём логического перестроения заданных связей в новом порядке.

TODO

### Сбор изменений справочников

TODO

### Агрегатор изменений справочников

TODO

### Распределенный планировщик для управления заданиями

Основные элементы: MvRunner, MvCoordinator

В каждом процессе свой экземпляр MvRunner, который обеспечивает локальный запуск и остановку заданий. Каждый MvRunner должен регулярно отправлять отчеты о своем состоянии в таблицу YDB "mv_runners".

MvCoordinator должен запускаться глобально (в рамках всей системы) в единственном экземпляре, и обеспечивает назначение заданий конкретным экземплярам MvRunner.

```sql
-- Редактируется сторонним приложением
CREATE TABLE mv_handlers ( -- в девичестве desired_state
    job_name Text NOT NULL, -- MvHandler.getName()
    job_settings JsonDocument, -- сериализованный MvHandlerSettings / MvDictionarySettings
    should_run Boolean, -- должен ли работать
    PRIMARY KEY(job_name)
);

-- Регулярно обновляется экземплярами MvRunner
CREATE TABLE mv_runners (
    runner_id Text NOT NULL, -- уникальный идентификатор, генерируется заново при старте
    runner_identity Text, -- имя хоста, id процесса, id контейнера - всё информационно
    updated_at Timestamp, -- метка времени последнего пинга
    PRIMARY KEY(runner_id)
);

-- Управляется MvRunner
CREATE TABLE mv_runner_jobs (
    runner_id Text NOT NULL,
    job_name Text NOT NULL,
    job_settings JsonDocument,
    started_at Timestamp,
    PRIMARY KEY(runner_id, job_name)
);

-- Новые записи добавляются MvCoordinator, поля статуса и диагностической информации обновляются MvRunner
CREATE TABLE mv_commands (
    runner_id Text NOT NULL,
    command_no Uint64 NOT NULL,
    created_at Timestamp,
    command_type Text, -- START / STOP
    job_name Text,
    job_settings JsonDocument,
    command_status Text, -- CREATED / TAKEN / SUCCESS / ERROR
    command_diag Text,
    PRIMARY KEY(runner_id, command_no)
);
```

Распределенный планировщик настраивается таблицей mv_handlers, где перечислены обработчики (MvHandler), которые должны быть запущены. Есть два специальных имени обработчиков: sys$dictionary (сканер изменений справочников) и sys$coordinator (собственно распределённый планировщик), которые нельзя использовать в именовании обычных обработчиков (MvHandler).

Каждый экземпляр MvRunner должен регулярно проверять содержимое таблицы "mv_commands". При появлении там новых записей - запускать выполнять соответствующие операции по запуску и остановке соответствующих заданий-обработчиков.

Поле диагностики команды для успешных команд должно быть NULL, а для ошибок состояние команды должно быть "ERROR", а поле диагностики должно содержать полную трассировку стека исключений.

Когда MvRunner выбирает новую команду, он должен попытаться выполнить её, вызвав соответствующие методы MvService.startHandler()/stopHandler(). После запуске обработчика в таблицу "mv_runner_jobs" необходимо добавить строку, содержащую сведения о запущенном обработчике, а в таблице "mv_commands" обновить статус на успешный. После остановки обработчика соответствующая строка должна быть удалена из таблицы "mv_runner_jobs".

MvCoordinator также регистрируется в табличке mv_runner_jobs со специальным именем обработчика, при длительном отсутствии активности MvCoordinator происходит выбор лидера через CoordinationService и запуск MvCoordinator на процессе-победителе. 

Запущенный MvCoordinator должен регулярно проверять содержимое табличек mv_handlers, mv_runner_jobs и mv_runner. Действия:
- неактивные mv_runner вычищаются из БД вместе со связанными записями из mv_runner_jobs
- при наличии запущенных "лишних" заданий (которых нет в mv_handlers) в mv_commands добавляются команды на остановку лишнего
- при наличии "недостающих" заданий (есть в mv_handlers, нет в mv_runner_jobs) в mv_commands добавляются команды на запуск недостающего

При принятии решения о записи новых команд в mv_commands контролируется отсутствие ещё не выполненных дубликатов.

Фактические имена таблиц и период сканирования/обновления состояния таблиц должны быть настраиваемыми, для этого следует предусмотреть класс настроек и возможность их подать через Properties.